# SQL Autocomplete Test Suite Design

## Overview

Comprehensive test suite for the SQL autocomplete engine in `flowscope-core`. The suite aims to provide regression coverage, serve as living documentation, and enable safe refactoring of internals.

## Scope

Focus areas (in priority order):
1. **Clause detection** - Cursor position correctly identifies SQL clauses
2. **Schema resolution** - Table/column lookups with schemas, catalogs, aliases
3. **Qualifier handling** - `alias.`, `table.`, `schema.table.` prefix resolution
4. **Scoring/ranking** - Correct ordering based on context and prefix matching

Minimal robustness coverage is included (whitespace, comments, quoted identifiers) but exhaustive edge case testing (UTF-8 boundaries, large inputs) is out of scope.

## Test Architecture

### Files

```
crates/flowscope-core/tests/
├── completion_items.rs      # Existing + new unit tests (~57 tests)
├── completion_snapshots.rs  # New snapshot tests (~16 tests)
└── snapshots/
    └── completion_snapshots__*.snap  # Generated by insta
```

### Testing Style

- **Unit tests**: Explicit `assert_eq!`/`assert!` for specific behaviors (clause detection, scoring order)
- **Snapshot tests**: Full `CompletionItemsResult` serialized to JSON for complex scenarios
- **Dialect coverage**: Snapshots capture dialect differences; unit tests default to DuckDB

### Shared Infrastructure

```rust
/// Creates a CompletionRequest with cursor at the "|" marker position.
/// Example: "SELECT | FROM users" places cursor after SELECT.
fn request_at_cursor(sql: &str, schema: Option<SchemaMetadata>) -> CompletionRequest {
    let cursor_offset = sql.find('|').expect("sql must contain cursor marker '|'");
    let clean_sql = sql.replace('|', "");
    CompletionRequest {
        sql: clean_sql,
        dialect: Dialect::Duckdb,
        cursor_offset,
        schema,
    }
}

/// Two-table schema: users (id, email) and orders (id, total, user_id)
/// Uses default_schema = "public"
fn schema_users_orders() -> SchemaMetadata {
    SchemaMetadata {
        default_catalog: None,
        default_schema: Some("public".to_string()),
        search_path: None,
        case_sensitivity: None,
        allow_implied: true,
        tables: vec![
            SchemaTable {
                catalog: None,
                schema: Some("public".to_string()),
                name: "users".to_string(),
                columns: vec![
                    ColumnSchema { name: "id".to_string(), data_type: Some("integer".to_string()), .. },
                    ColumnSchema { name: "email".to_string(), data_type: Some("varchar".to_string()), .. },
                ],
            },
            SchemaTable {
                catalog: None,
                schema: Some("public".to_string()),
                name: "orders".to_string(),
                columns: vec![
                    ColumnSchema { name: "id".to_string(), data_type: Some("integer".to_string()), .. },
                    ColumnSchema { name: "total".to_string(), data_type: Some("decimal".to_string()), .. },
                    ColumnSchema { name: "user_id".to_string(), data_type: Some("integer".to_string()), .. },
                ],
            },
        ],
    }
}

/// Multi-schema: public.users, analytics.events
fn schema_multi_schema() -> SchemaMetadata { ... }

/// Ambiguous columns: id column exists in multiple tables
fn schema_ambiguous_columns() -> SchemaMetadata { ... }

/// Catalog-qualified schema: sales.public.customers
fn schema_with_catalog() -> SchemaMetadata {
    SchemaMetadata {
        default_catalog: Some("sales".to_string()),
        default_schema: Some("public".to_string()),
        // ...
        tables: vec![
            SchemaTable {
                catalog: Some("sales".to_string()),
                schema: Some("public".to_string()),
                name: "customers".to_string(),
                // ...
            },
        ],
    }
}
```

## Test Coverage

### 1. Clause Detection (~20 tests)

Unit tests verifying `context.clause` and `context.statement_index`.

| Test | SQL | Expected Clause |
|------|-----|-----------------|
| `test_clause_select` | `SELECT \| FROM users` | Select |
| `test_clause_select_after_column` | `SELECT id, \| FROM users` | Select |
| `test_clause_from` | `SELECT * FROM \|` | From |
| `test_clause_from_after_table` | `SELECT * FROM users, \|` | From |
| `test_clause_where` | `SELECT * FROM users WHERE \|` | Where |
| `test_clause_where_mid_expr` | `SELECT * FROM t WHERE id = \|` | Where |
| `test_clause_join` | `SELECT * FROM a JOIN \|` | Join |
| `test_clause_on` | `SELECT * FROM a JOIN b ON \|` | On |
| `test_clause_group_by` | `SELECT * FROM t GROUP BY \|` | GroupBy |
| `test_clause_having` | `SELECT * FROM t GROUP BY x HAVING \|` | Having |
| `test_clause_order_by` | `SELECT * FROM t ORDER BY \|` | OrderBy |
| `test_clause_limit` | `SELECT * FROM t LIMIT \|` | Limit |
| `test_clause_insert` | `INSERT \|` | Insert |
| `test_clause_update` | `UPDATE \|` | Update |
| `test_clause_delete` | `DELETE \|` | Delete |
| `test_clause_with` | `WITH cte AS (\|` | With |
| `test_clause_multi_stmt_first` | `SELECT \|; SELECT * FROM t` | Select (index 0) |
| `test_clause_multi_stmt_second` | `SELECT 1; SELECT * FROM \|` | From (index 1) |

#### Robustness (whitespace/comments)

| Test | SQL | Expected |
|------|-----|----------|
| `test_clause_cursor_in_whitespace` | `SELECT  \|  FROM users` | Select (handles extra whitespace) |
| `test_clause_after_comment` | `SELECT /* comment */ \| FROM users` | Select |

### 2. Schema Resolution (~15 tests)

#### Context tests (tables_in_scope, columns_in_scope)

| Test | SQL | Assertion |
|------|-----|-----------|
| `test_schema_table_in_from` | `SELECT * FROM users\|` | tables_in_scope includes "users" |
| `test_schema_table_with_alias` | `SELECT * FROM users u\|` | table has alias "u" |
| `test_schema_multiple_tables` | `SELECT * FROM users, orders\|` | both tables in scope |
| `test_schema_join_tables` | `SELECT * FROM a JOIN b ON \|` | both a and b in scope |
| `test_schema_columns_from_table` | `SELECT \| FROM users` | columns include id, email |
| `test_schema_columns_joined` | `SELECT \| FROM users u JOIN orders o ON ...` | columns from both, ambiguous marked |
| `test_schema_qualified_table` | `SELECT * FROM public.users\|` | canonical = "public.users" |
| `test_schema_default_resolution` | `SELECT * FROM users\|` | resolves via default_schema |
| `test_schema_case_insensitive` | `SELECT * FROM USERS\|` | matches "users" in schema |
| `test_schema_quoted_preserves` | `SELECT * FROM "Users"\|` | preserves exact case |

#### Catalog-qualified names (minimal coverage)

| Test | SQL | Assertion |
|------|-----|-----------|
| `test_schema_catalog_qualified` | `SELECT * FROM sales.public.customers\|` | canonical includes catalog |
| `test_schema_catalog_default` | `SELECT * FROM customers\|` | resolves via default_catalog + default_schema |
| `test_qualifier_catalog_schema` | `SELECT * FROM sales.public.\|` | shows tables in sales.public |

#### Items tests (completion suggestions)

| Test | SQL | Assertion |
|------|-----|-----------|
| `test_items_columns_in_select` | `SELECT \| FROM users` | items include id, email columns |
| `test_items_tables_in_from` | `SELECT * FROM \|` | items include users, orders |

### 3. Qualifier Handling (~13 tests)

#### Alias qualifiers

| Test | SQL | Assertion |
|------|-----|-----------|
| `test_qualifier_alias_lower` | `SELECT u.\| FROM users u` | only users columns |
| `test_qualifier_alias_upper` | `SELECT U.\| FROM users U` | case-insensitive match |
| `test_qualifier_alias_partial` | `SELECT u.em\| FROM users u` | filters to "email" |
| `test_qualifier_alias_excludes` | `SELECT u.\| FROM users u JOIN orders o` | excludes orders columns |

#### Table name qualifiers

| Test | SQL | Assertion |
|------|-----|-----------|
| `test_qualifier_table_name` | `SELECT users.\| FROM users` | users columns only |
| `test_qualifier_table_joined` | `SELECT users.\| FROM users JOIN orders` | only users columns |

#### Schema qualifiers

| Test | SQL | Assertion |
|------|-----|-----------|
| `test_qualifier_schema_only` | `SELECT * FROM public.\|` | SchemaTable items only |
| `test_qualifier_schema_table` | `SELECT public.users.\| FROM public.users` | columns from public.users |

#### Edge cases

| Test | SQL | Assertion |
|------|-----|-----------|
| `test_qualifier_subquery_alias` | `SELECT sq.\| FROM (SELECT id FROM t) sq` | alias recognized |
| `test_no_qualifier_all_columns` | `SELECT \| FROM users u JOIN orders o` | all columns shown |
| `test_ambiguous_column_prefixed` | `SELECT id\| FROM users JOIN orders` | suggests prefixed columns |

#### Robustness (quoted identifiers/strings)

| Test | SQL | Assertion |
|------|-----|-----------|
| `test_cursor_inside_quoted_identifier` | `SELECT "user\|_name" FROM t` | should_show = false |
| `test_cursor_inside_string_literal` | `SELECT 'hello\|world' FROM t` | should_show = false |

### 4. Scoring and Ranking (~9 tests)

#### Scoring algorithm

The scoring follows this precedence (highest to lowest):
1. **Category score** - Based on clause context (e.g., columns rank higher in SELECT)
2. **Prefix score** - Exact match (300) > prefix match (200) > contains (100) > no match (0)
3. **Clause-specific bonus** - Items marked `clause_specific: true` get +50
4. **Special rules** - e.g., FROM keyword boost when typing "f" in SELECT

Tie-breaker: alphabetical by lowercase label.

#### Clause-specific category ordering

| Test | SQL | Assertion |
|------|-----|-----------|
| `test_score_select_columns_first` | `SELECT \| FROM users` | columns before tables |
| `test_score_from_tables_first` | `SELECT * FROM \|` | tables before columns |
| `test_score_where_columns_ops` | `SELECT * FROM users WHERE \|` | columns ranked high |
| `test_score_order_by_columns` | `SELECT * FROM users ORDER BY \|` | columns first |

#### Prefix matching

| Test | SQL | Assertion |
|------|-----|-----------|
| `test_score_exact_match` | `SELECT email\|` | "email" above "email_verified" |
| `test_score_prefix_vs_contains` | `SELECT user\| FROM users` | "user_id" above "power_user" |
| `test_score_column_name_match` | `SELECT em\| FROM users u` | matches column name |

#### Special rules

| Test | SQL | Assertion |
|------|-----|-----------|
| `test_score_from_boost_on_f` | `SELECT f\|` | "FROM" ranked near top |

#### Tie-breaker

| Test | SQL | Assertion |
|------|-----|-----------|
| `test_score_alphabetical_tiebreak` | `SELECT \| FROM t` | same-score items sorted alphabetically |

### 5. Snapshot Tests (~16 tests)

Full `CompletionItemsResult` snapshots in `completion_snapshots.rs`:

| Test | Description |
|------|-------------|
| `snap_select_with_schema` | SELECT clause with full schema |
| `snap_from_clause_tables` | FROM clause table suggestions |
| `snap_join_on_condition` | JOIN ON clause columns |
| `snap_qualified_alias` | Alias-qualified completions |
| `snap_qualified_schema` | Schema-qualified completions |
| `snap_three_way_join` | Complex 3-table join |
| `snap_ambiguous_columns` | Multiple tables, same column names |
| `snap_duckdb_dialect` | DuckDB-specific completions |
| `snap_postgres_dialect` | Postgres-specific completions |
| `snap_keywords_select_clause` | Keyword hints for SELECT |
| `snap_keywords_where_clause` | Keyword hints for WHERE |
| `snap_keywords_order_by_clause` | Keyword hints for ORDER BY |
| `snap_comment_handling` | Cursor next to comments |
| `snap_multi_statement` | Multi-statement completion |
| `snap_cte_reference` | WITH clause CTE reference |
| `snap_empty_schema` | Behavior without schema |

## Running Tests

```bash
# All core tests
just test-core

# Just completion tests
cargo test -p flowscope-core completion

# Review snapshot changes
cargo insta review
```

## Test Counts Summary

| Area | Unit Tests | Snapshot Tests |
|------|------------|----------------|
| Clause detection | 20 | - |
| Schema resolution | 15 | 2 |
| Qualifier handling | 13 | 3 |
| Scoring/ranking | 9 | - |
| Multi-table/complex | - | 5 |
| Dialect/keywords | - | 5 |
| Robustness | - | 1 |
| **Total** | **57** | **16** |
