    fn analyze_statement(
        &mut self,
        index: usize,
        statement: &Statement,
    ) -> Result<StatementLineage, ParseError> {
        let mut ctx = StatementContext::new(index);

        let statement_type = match statement {
            Statement::Query(query) => {
                self.analyze_query(&mut ctx, query, None);
                classify_query_type(query)
            }
            Statement::Insert(insert) => {
                self.analyze_insert(&mut ctx, insert);
                "INSERT".to_string()
            }
            Statement::CreateTable(create) => {
                if let Some(query) = &create.query {
                    self.analyze_create_table_as(&mut ctx, &create.name, query);
                    "CREATE_TABLE_AS".to_string()
                } else {
                    "CREATE_TABLE".to_string()
                }
            }
            Statement::Update {
                table,
                assignments: _,
                from,
                selection,
                returning: _,
            } => {
                self.analyze_update(&mut ctx, table, from, selection);
                "UPDATE".to_string()
            }
            Statement::Delete {
                tables: _, // For MySQL multi-table delete, simplified here
                from,
                using,
                selection,
                returning: _,
            } => {
                self.analyze_delete(&mut ctx, from, using, selection);
                "DELETE".to_string()
            }
            Statement::Merge {
                into,
                table,
                source,
                on: _,
                clauses: _,
            } => {
                self.analyze_merge(&mut ctx, into, table, source);
                "MERGE".to_string()
            }
            _ => {
                self.issues.push(
                    Issue::warning(
                        issue_codes::UNSUPPORTED_SYNTAX,
                        "Statement type not fully supported for lineage analysis".to_string(),
                    )
                    .with_statement(index),
                );
                "UNKNOWN".to_string()
            }
        };

        Ok(StatementLineage {
            statement_index: index,
            statement_type,
            source_name: self.request.source_name.clone(),
            nodes: ctx.nodes,
            edges: ctx.edges,
            span: None,
        })
    }

    fn analyze_update(
        &mut self,
        ctx: &mut StatementContext,
        table: &TableWithJoins,
        from: &Option<TableWithJoins>,
        selection: &Option<Expr>,
    ) {
        // 1. Analyze the target table
        // The target table in UPDATE is the first table in `table.relation`
        self.analyze_table_factor(ctx, &table.relation, None);

        // Extract the target table name to use as the "target" for lineage edges
        // This is a bit tricky because analyze_table_factor adds it to ctx but doesn't return the ID directly
        // We can try to infer it or modify analyze_table_factor, but for now let's look at the table factor directly
        let target_id = if let TableFactor::Table { name, alias, .. } = &table.relation {
            let table_name = name.to_string();
            // We need to find the node ID for this table. It was just added.
            // We can use canonicalize_table_reference to find the canonical name and then look it up
            // Or we can re-resolve it.
            // Since we are inside the same context, we can look up the alias if present, or the table name.
            let lookup_name = alias.as_ref().map(|a| a.name.to_string()).unwrap_or(table_name.clone());
            
            // We need the canonical name to find the node ID
            // If it's an alias, look it up in table_aliases
            let canonical = if let Some(c) = ctx.table_aliases.get(&lookup_name) {
                Some(c.clone())
            } else {
                // If no alias, it might be a direct table reference
                let res = self.canonicalize_table_reference(&table_name);
                Some(res.canonical)
            };

            if let Some(c) = canonical {
                ctx.table_node_ids.get(&c).cloned()
            } else {
                None
            }
        } else {
            None
        };

        if let Some(target_node_id) = &target_id {
            // Register this table as being "produced" (modified) by this statement
            // We need to find the canonical name again to update produced_tables
            if let TableFactor::Table { name, .. } = &table.relation {
                 let canonical = self.normalize_table_name(&name.to_string());
                 self.produced_tables.insert(canonical, ctx.statement_index);
            }
        }

        // 2. Analyze FROM clause (Postgres style)
        if let Some(from_table) = from {
            self.analyze_table_with_joins(ctx, from_table, target_id.as_deref());
        }

        // 3. Analyze Joins in the target table (standard SQL, MySQL)
        for join in &table.joins {
             let join_type = "JOIN"; // Simplified
             ctx.last_operation = Some(join_type.to_string());
             self.analyze_table_factor(ctx, &join.relation, target_id.as_deref());
        }

        // 4. Analyze selection (WHERE clause) for column usage (optional, good for column lineage)
        if let Some(expr) = selection {
            self.extract_column_refs_for_validation(ctx, expr);
        }
    }

    fn analyze_delete(
        &mut self,
        ctx: &mut StatementContext,
        from: &FromTable, // This type depends on sqlparser version, might be TableWithJoins or list
        using: &Option<Vec<TableWithJoins>>,
        selection: &Option<Expr>,
    ) {
        // sqlparser AST for DELETE changed recently.
        // It uses `tables` (for MySQL) and `from` (which is now Vec<TableWithJoins> or similar)
        // Let's check the signature in `analyze_statement`. 
        // The `analyze_statement` above used `from` and `using`.
        // Let's assume standard `DELETE FROM table` first.
        
        let target_ids = self.analyze_delete_targets(ctx, from);
        
        // If we found targets, any subsequent tables (USING clause) feed into them
        // If multiple targets (MySQL), they all get fed.
        
        if let Some(using_tables) = using {
            for table in using_tables {
                for target_id in &target_ids {
                    self.analyze_table_with_joins(ctx, table, Some(target_id));
                }
            }
        }

        if let Some(expr) = selection {
            self.extract_column_refs_for_validation(ctx, expr);
        }
    }

    // Helper to handle different DELETE FROM structures
    fn analyze_delete_targets(&mut self, ctx: &mut StatementContext, from: &FromTable) -> Vec<String> {
        let mut target_ids = Vec::new();
        
        match from {
             // Single table delete: DELETE FROM table
             FromTable::Table(table_with_joins) => {
                 // The first table is the target
                 self.analyze_table_factor(ctx, &table_with_joins.relation, None);
                 if let Some(id) = self.get_table_factor_node_id(ctx, &table_with_joins.relation) {
                     target_ids.push(id);
                 }
                 
                 // Any joins in the FROM clause are sources (MySQL style)
                 // DELETE T1 FROM T1 JOIN T2 ON ...
                 for join in &table_with_joins.joins {
                     for target_id in &target_ids {
                         self.analyze_table_factor(ctx, &join.relation, Some(target_id));
                     }
                 }
             },
             // Multi-table delete (if supported by parser as list)
             FromTable::List(tables) => {
                 for table in tables {
                     self.analyze_table_with_joins(ctx, table, None);
                     // In multi-table delete, which ones are targets?
                     // Usually specified in `tables` field of Delete struct.
                     // For now, treat all in FROM as potential sources/targets depending on dialect.
                     // Lineage-wise, it's safe to register them.
                 }
             }
        }
        target_ids
    }

    fn analyze_merge(
        &mut self,
        ctx: &mut StatementContext,
        into: &bool, // unused
        table: &TableFactor,
        source: &TableFactor,
    ) {
        // 1. Analyze Target Table
        self.analyze_table_factor(ctx, table, None);
        let target_id = self.get_table_factor_node_id(ctx, table);

        if let Some(ref id) = target_id {
             if let TableFactor::Table { name, .. } = table {
                 let canonical = self.normalize_table_name(&name.to_string());
                 self.produced_tables.insert(canonical, ctx.statement_index);
             }
        }

        // 2. Analyze Source Table
        // The source feeds into the target
        self.analyze_table_factor(ctx, source, target_id.as_deref());
    }

    // Helper to get node ID from a table factor that was just analyzed
    fn get_table_factor_node_id(&self, ctx: &StatementContext, table: &TableFactor) -> Option<String> {
        match table {
            TableFactor::Table { name, alias, .. } => {
                let table_name = name.to_string();
                let lookup_name = alias.as_ref().map(|a| a.name.to_string()).unwrap_or(table_name.clone());
                
                if let Some(c) = ctx.table_aliases.get(&lookup_name) {
                    ctx.table_node_ids.get(c).cloned()
                } else {
                    let res = self.canonicalize_table_reference(&table_name);
                    ctx.table_node_ids.get(&res.canonical).cloned()
                }
            },
            _ => None
        }
    }
